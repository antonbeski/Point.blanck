# app.py
"""
POINT BLANK — Single-page iOS-style Dark Streamlit app
- Yahoo Finance data
- Indicators: MA20, MA50, EMA, RSI, MACD, Bollinger Bands
- Forecasts: Prophet, ARIMA, Random Forest, LSTM (run only if libs installed)
- Recent News display with clickable card + image + metadata
"""

import warnings
warnings.filterwarnings("ignore")

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import timedelta, datetime, timezone
import time

# --------------------------
# Optional ML libraries (safe imports)
# --------------------------
HAS_PROPHET = False
HAS_ARIMA = False
HAS_SKLEARN = False
HAS_TF = False

try:
    from prophet import Prophet
    HAS_PROPHET = True
except Exception:
    Prophet = None

try:
    from statsmodels.tsa.arima.model import ARIMA
    HAS_ARIMA = True
except Exception:
    ARIMA = None

try:
    from sklearn.ensemble import RandomForestRegressor
    from sklearn.preprocessing import MinMaxScaler
    HAS_SKLEARN = True
except Exception:
    RandomForestRegressor = None
    MinMaxScaler = None

try:
    import tensorflow as tf
    from tensorflow import keras
    from tensorflow.keras import layers
    HAS_TF = True
except Exception:
    tf = None
    keras = None
    layers = None

# --------------------------
# Streamlit page config + CSS
# --------------------------
st.set_page_config(page_title="POINT.BLANK", layout="wide")
st.markdown(
    """
<style>
body, .stApp {background-color: #000000; color: #E6E6E6; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', Roboto, sans-serif;}
.block-container {padding-top: 1.5rem; max-width: 1150px; margin-left:auto; margin-right:auto;}
.stButton>button {background-color: #1C1C1E; color: #E6E6E6; border-radius: 12px; border: 1px solid #2C2C2E; padding: 0.55em 1em;}
.stTextInput>div>div>input, .stSelectbox>div>div, .stSlider>div>div {background-color: #0F0F10; color: #E6E6E6; border-radius: 10px; border: 1px solid #222224;}
.stCheckbox>div, .stRadio>div {color: #E6E6E6;}
h1, h2, h3, h4 {color: #E6E6E6; text-align: center;}
.model-availability {background-color:#0B0B0C; padding:8px; border-radius:8px; border:1px solid #202022;}
.news-card {background-color:#0F0F10; border:1px solid #2C2C2E; border-radius:12px; padding:12px; margin-bottom:12px; display:flex; gap:12px; align-items:center;}
.news-image {width:120px; height:80px; object-fit:cover; border-radius:8px;}
.news-title {font-weight:600; color:#E6E6E6; margin:0;}
.news-meta {font-size:12px; color:#9E9E9E; margin-top:6px;}
a {color:#4DA6FF; text-decoration:none;}
a:hover {text-decoration:underline;}
.small-muted {font-size:12px; color:#9E9E9E;}
</style>
""",
    unsafe_allow_html=True,
)

# --------------------------
# Disclaimer Gate
# --------------------------
st.markdown("## ⚠️ Disclaimer")
st.markdown(
    """
Point blank provides stock market data, analysis, and predictive tools for **educational and informational purposes only**.  

- Point blank does **not** provide financial, investment, trading, or legal advice.  
- All information, forecasts, and analytics generated by Point blank are **estimates only** and may be inaccurate, incomplete, or outdated.  
- Stock market investments are inherently **risky and volatile**. Past performance is not indicative of future results.  
- Users are solely responsible for any investment or trading decisions made based on Point blank’s content.  
- The developers, owners, affiliates, and contributors of Point blank shall **not be held liable** for any financial losses, damages, or consequences arising directly or indirectly from its use.  

By using Point blank, you acknowledge that you understand these risks and agree to use Point blank at your own discretion and responsibility.  
For personalized financial guidance, please consult a licensed financial advisor.
"""
)

accept = st.checkbox(" I have read and accept the disclaimer")

if not accept:
    st.warning("⚠️ Please accept the disclaimer to use Point blank.")
    st.stop()

# --------------------------
# Utilities: Data + News + Indicators + Plotting
# --------------------------
@st.cache_data(ttl=300, show_spinner=False)
def fetch_yahoo_data(ticker: str, period="6mo", interval="1d") -> pd.DataFrame:
    try:
        t = yf.Ticker(ticker)
        df = t.history(period=period, interval=interval)
        if df is None or df.empty:
            return pd.DataFrame()
        df = df.reset_index()
        df['Date'] = pd.to_datetime(df['Date']).dt.tz_localize(None)
        for col in ['Open', 'High', 'Low', 'Close', 'Volume']:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
        df = df.dropna(subset=['Date', 'Close']).reset_index(drop=True)
        return df
    except Exception:
        return pd.DataFrame()


def _safe_extract_image(n):
    # yfinance news item structures vary. try common keys
    for k in ("image", "thumbnail", "thumbnail_url", "img", "media"):
        val = n.get(k)
        if not val:
            continue
        # sometimes dict with 'thumbnail' or 'resolved_url'
        if isinstance(val, dict):
            for subk in ("url", "thumbnail", "src", "image"):
                if subk in val and val[subk]:
                    return val[subk]
            # look deeper
            for v in val.values():
                if isinstance(v, str) and v.startswith("http"):
                    return v
        elif isinstance(val, str) and val.startswith("http"):
            return val
    # fallback: try 'link' domain favicon (not great) — return None so placeholder used
    return None


def fetch_news(ticker: str, max_items: int = 6):
    """Return list of dicts with keys: title, link, publisher, time, img"""
    try:
        t = yf.Ticker(ticker)
        news = t.news if hasattr(t, "news") else []
        items = []
        for n in news[:max_items]:
            ts = n.get("providerPublishTime", None) or n.get("pubDate", None)
            dt = None
            if isinstance(ts, (int, float)):
                try:
                    dt = datetime.fromtimestamp(int(ts), tz=timezone.utc).astimezone()
                except Exception:
                    dt = None
            elif isinstance(ts, str):
                try:
                    dt = datetime.fromisoformat(ts)
                except Exception:
                    dt = None
            rel_time = dt.strftime("%Y-%m-%d %H:%M") if dt else ""
            img = _safe_extract_image(n)
            items.append(
                {
                    "title": n.get("title", "") or n.get("headline", ""),
                    "link": n.get("link", ""),
                    "publisher": n.get("publisher", "") or n.get("source", ""),
                    "time": rel_time,
                    "img": img,
                }
            )
        return items
    except Exception:
        return []


def compute_indicators(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy().reset_index(drop=True)
    df['MA20'] = df['Close'].rolling(20).mean()
    df['MA50'] = df['Close'].rolling(50).mean()
    df['EMA12'] = df['Close'].ewm(span=12, adjust=False).mean()
    df['EMA26'] = df['Close'].ewm(span=26, adjust=False).mean()
    df['MACD'] = df['EMA12'] - df['EMA26']
    df['Signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
    df['BB_MID'] = df['Close'].rolling(20).mean()
    df['BB_STD'] = df['Close'].rolling(20).std(ddof=0).fillna(0)
    df['BB_UP'] = df['BB_MID'] + 2 * df['BB_STD']
    df['BB_LOW'] = df['BB_MID'] - 2 * df['BB_STD']
    delta = df['Close'].diff()
    up = delta.clip(lower=0)
    down = -delta.clip(upper=0)
    roll_up = up.rolling(14).mean()
    roll_down = down.rolling(14).mean()
    rs = roll_up / (roll_down + 1e-8)
    df['RSI'] = 100 - (100 / (1 + rs))
    df['RSI'] = df['RSI'].clip(0, 100).fillna(50)
    return df


def plot_advanced(df: pd.DataFrame, title: str, show_indicators: bool = True):
    fig = make_subplots(rows=3, cols=1, shared_xaxes=True,
                        row_heights=[0.62, 0.18, 0.20],
                        vertical_spacing=0.03)
    fig.add_trace(go.Candlestick(x=df['Date'], open=df['Open'], high=df['High'],
                                 low=df['Low'], close=df['Close'], name='Price'), row=1, col=1)
    if show_indicators:
        fig.add_trace(go.Scatter(x=df['Date'], y=df['MA20'], name='MA20', line=dict(width=1.4)), row=1, col=1)
        fig.add_trace(go.Scatter(x=df['Date'], y=df['MA50'], name='MA50', line=dict(width=1.4, dash='dash')), row=1, col=1)
        fig.add_trace(go.Scatter(x=df['Date'], y=df['BB_UP'], name='BB_UP', line=dict(width=1, dash='dot')), row=1, col=1)
        fig.add_trace(go.Scatter(x=df['Date'], y=df['BB_LOW'], name='BB_LOW', line=dict(width=1, dash='dot')), row=1, col=1)
    fig.add_trace(go.Bar(x=df['Date'], y=df['Volume'], name='Volume', opacity=0.35), row=2, col=1)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['RSI'], name='RSI', line=dict(width=1.2)), row=3, col=1)
    fig.add_hline(y=70, line_dash='dot', row=3, col=1)
    fig.add_hline(y=30, line_dash='dot', row=3, col=1)
    fig.update_layout(template='plotly_dark', title=title,
                      margin=dict(l=20, r=20, t=40, b=10),
                      paper_bgcolor='#000000', plot_bgcolor='#000000',
                      legend=dict(orientation='h', yanchor='bottom', y=1.02, xanchor='right', x=1))
    st.plotly_chart(fig, use_container_width=True, theme=None)


# --------------------------
# Forecast helpers (cached where appropriate)
# --------------------------
@st.cache_data(ttl=3600, show_spinner=False)
def prophet_forecast(df: pd.DataFrame, periods: int = 30):
    if not HAS_PROPHET:
        return None
    dfp = df[['Date', 'Close']].rename(columns={'Date': 'ds', 'Close': 'y'})
    m = Prophet()
    m.fit(dfp)
    future = m.make_future_dataframe(periods=periods)
    forecast = m.predict(future)
    return forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(periods)


@st.cache_data(ttl=3600, show_spinner=False)
def arima_forecast(df: pd.DataFrame, periods: int = 30):
    if not HAS_ARIMA:
        return None
    series = df.set_index('Date')['Close'].asfreq(df['Date'].diff().mode()[0]).fillna(method='ffill')
    # simple ARIMA(5,1,0) as fallback — users can extend to auto_arima if desired
    model = ARIMA(series, order=(5, 1, 0))
    model_fit = model.fit()
    pred = model_fit.get_forecast(steps=periods)
    idx = pd.date_range(start=series.index[-1] + pd.Timedelta(1, unit='D'), periods=periods, freq='D')
    forecast = pd.DataFrame({
        'ds': idx,
        'yhat': pred.predicted_mean,
        'yhat_lower': pred.conf_int().iloc[:, 0],
        'yhat_upper': pred.conf_int().iloc[:, 1]
    })
    return forecast


@st.cache_data(ttl=3600, show_spinner=False)
def rf_forecast(df: pd.DataFrame, periods: int = 30, n_lags: int = 5):
    if not HAS_SKLEARN:
        return None
    dd = df[['Date', 'Close']].copy()
    dd = dd.set_index('Date')
    for lag in range(1, n_lags + 1):
        dd[f'lag_{lag}'] = dd['Close'].shift(lag)
    dd = dd.dropna()
    X = dd[[f'lag_{l}' for l in range(1, n_lags + 1)]].values
    y = dd['Close'].values
    # train-test split minimal: train on everything
    model = RandomForestRegressor(n_estimators=200, random_state=42)
    model.fit(X, y)
    last_vals = dd.iloc[-1][[f'lag_{l}' for l in range(1, n_lags + 1)]].values
    preds = []
    cur = last_vals.copy()
    for i in range(periods):
        pred = model.predict(cur.reshape(1, -1))[0]
        preds.append(pred)
        cur = np.roll(cur, 1)
        cur[0] = pred
    idx = pd.date_range(start=df['Date'].iloc[-1] + pd.Timedelta(1, unit='D'), periods=periods, freq='D')
    forecast = pd.DataFrame({'ds': idx, 'yhat': preds})
    return forecast


@st.cache_data(ttl=3600, show_spinner=False)
def lstm_forecast(df: pd.DataFrame, periods: int = 30, seq_len: int = 30, epochs: int = 15):
    if not HAS_TF:
        return None
    series = df.set_index('Date')['Close'].astype('float32')
    scaler = MinMaxScaler()
    vals = scaler.fit_transform(series.values.reshape(-1, 1))
    X, y = [], []
    for i in range(seq_len, len(vals)):
        X.append(vals[i - seq_len:i, 0])
        y.append(vals[i, 0])
    X, y = np.array(X), np.array(y)
    X = X.reshape((X.shape[0], X.shape[1], 1))
    model = keras.Sequential([
        layers.Input(shape=(seq_len, 1)),
        layers.LSTM(64, return_sequences=False),
        layers.Dense(32, activation='relu'),
        layers.Dense(1)
    ])
    model.compile(optimizer='adam', loss='mse')
    model.fit(X, y, epochs=epochs, batch_size=16, verbose=0)
    # forecasting
    cur = vals[-seq_len:].reshape(1, seq_len, 1)
    preds = []
    for _ in range(periods):
        p = model.predict(cur, verbose=0)[0, 0]
        preds.append(p)
        cur = np.roll(cur, -1)
        cur[0, -1, 0] = p
    preds = scaler.inverse_transform(np.array(preds).reshape(-1, 1)).flatten()
    idx = pd.date_range(start=df['Date'].iloc[-1] + pd.Timedelta(1, unit='D'), periods=periods, freq='D')
    forecast = pd.DataFrame({'ds': idx, 'yhat': preds})
    return forecast


# --------------------------
# Main UI
# --------------------------
st.title("POINT BLANK")

tickers_list = [
    "AAPL","MSFT","GOOG","AMZN","TSLA","META","NVDA","JPM","V","JNJ","WMT",
    "RELIANCE.NS","TCS.NS","INFY.NS","HDFCBANK.NS","ICICIBANK.NS","SBIN.NS",
    "BTC-USD","ETH-USD"
]

controls = st.columns([2, 2, 2, 2, 1])
with controls[0]:
    ticker = st.selectbox("Ticker", tickers_list, index=0)
with controls[1]:
    period = st.selectbox("History period", ["1mo", "3mo", "6mo", "1y", "2y", "5y", "10y", "max"], index=2)
with controls[2]:
    interval = st.selectbox("Interval", ["1d", "1wk", "1mo"], index=0)
with controls[3]:
    show_indicators = st.checkbox("Show Indicators", value=True)
with controls[4]:
    run = st.button("Run All")

st.markdown("---")

# Model availability display
st.markdown("### Model availability")
st.markdown(
    f"""<div class="model-availability">
- Prophet: {'✅' if HAS_PROPHET else '❌'}
- ARIMA (statsmodels): {'✅' if HAS_ARIMA else '❌'}
- RandomForest (sklearn): {'✅' if HAS_SKLEARN else '❌'}
- LSTM (tensorflow/keras): {'✅' if HAS_TF else '❌'}
</div>""",
    unsafe_allow_html=True,
)

if run:
    placeholder = st.empty()
    with placeholder.container():
        st.info("Fetching data and news...")

    df = fetch_yahoo_data(ticker, period, interval)
    if df.empty:
        st.error("No data retrieved. Check ticker or network.")
        st.stop()

    df = compute_indicators(df)

    last = df.iloc[-1]
    cols = st.columns([1, 1, 1, 1, 1])
    with cols[0]:
        st.metric("Date", str(pd.to_datetime(last['Date']).date()))
    with cols[1]:
        st.metric("Open", f"{last['Open']:.2f}")
    with cols[2]:
        st.metric("High", f"{last['High']:.2f}")
    with cols[3]:
        st.metric("Low", f"{last['Low']:.2f}")
    with cols[4]:
        st.metric("Close", f"{last['Close']:.2f}")

    plot_advanced(df, f"{ticker} — Price & Indicators", show_indicators)

    st.download_button("Download raw data (CSV)", df.to_csv(index=False), file_name=f"{ticker}_raw.csv", mime="text/csv")

    # --------------------------
    # NEWS SECTION (clickable card with image)
    # --------------------------
    st.subheader("📰 Recent News")
    news_items = fetch_news(ticker, max_items=6)
    if not news_items:
        st.info("No recent news available for this stock.")
    else:
        for n in news_items:
            img_html = ""
            if n.get("img"):
                # wrap image in anchor so whole card is clickable (image + title both link)
                img_html = f'<a href="{n["link"]}" target="_blank"><img class="news-image" src="{n["img"]}" onerror="this.style.display=\'none\'"></a>'
            else:
                # placeholder small square (keeps layout)
                img_html = '<div style="width:120px;height:80px;border-radius:8px;background:#111;margin-right:12px;"></div>'

            title = n.get("title", "No title")
            link = n.get("link", "#")
            publisher = n.get("publisher", "")
            time_str = n.get("time", "")

            card_html = f"""
            <div class="news-card">
                {img_html}
                <div style="flex:1">
                    <div style="display:flex; justify-content:space-between; align-items:flex-start;">
                        <a href="{link}" target="_blank" style="text-decoration:none; max-width:75%"><div class="news-title">{title}</div></a>
                        <div class="small-muted">{time_str}</div>
                    </div>
                    <div class="news-meta">{publisher}</div>
                </div>
            </div>
            """
            st.markdown(card_html, unsafe_allow_html=True)

    st.markdown("---")

    # --------------------------
    # Forecasting
    # --------------------------
    st.subheader("📈 Forecasts (next 30 days)")

    with st.expander("Run forecasts and show charts"):
        forecast_days = st.number_input("Forecast horizon (days)", min_value=7, max_value=180, value=30, step=1)
        run_models = st.button("Run Forecast Models")

        if run_models:
            model_placeholder = st.empty()
            with model_placeholder.container():
                st.info("Running available forecast models. This may take time for some models...")

            # Prophet
            if HAS_PROPHET:
                try:
                    fprop = prophet_forecast(df, periods=forecast_days)
                    if fprop is not None:
                        st.markdown("#### Prophet")
                        st.line_chart(fprop.set_index('ds')['yhat'])
                        st.dataframe(fprop.reset_index(drop=True).head(forecast_days), use_container_width=True)
                except Exception as e:
                    st.error(f"Prophet failed: {e}")
            else:
                st.markdown("Prophet: Not available on this environment.")

            # ARIMA
            if HAS_ARIMA:
                try:
                    farima = arima_forecast(df, periods=forecast_days)
                    if farima is not None:
                        st.markdown("#### ARIMA")
                        st.line_chart(farima.set_index('ds')['yhat'])
                        st.dataframe(farima.head(forecast_days), use_container_width=True)
                except Exception as e:
                    st.error(f"ARIMA failed: {e}")
            else:
                st.markdown("ARIMA: Not available on this environment.")

            # RandomForest
            if HAS_SKLEARN:
                try:
                    frf = rf_forecast(df, periods=forecast_days)
                    if frf is not None:
                        st.markdown("#### Random Forest (lag-based)")
                        st.line_chart(frf.set_index('ds')['yhat'])
                        st.dataframe(frf.head(forecast_days), use_container_width=True)
                except Exception as e:
                    st.error(f"Random Forest failed: {e}")
            else:
                st.markdown("RandomForest (sklearn): Not available on this environment.")

            # LSTM
            if HAS_TF:
                try:
                    flstm = lstm_forecast(df, periods=forecast_days, seq_len=30, epochs=10)
                    if flstm is not None:
                        st.markdown("#### LSTM")
                        st.line_chart(flstm.set_index('ds')['yhat'])
                        st.dataframe(flstm.head(forecast_days), use_container_width=True)
                except Exception as e:
                    st.error(f"LSTM failed: {e}")
            else:
                st.markdown("LSTM (tensorflow/keras): Not available on this environment.")

            model_placeholder.empty()

    st.markdown("---")
    st.subheader("Recent data (tail)")
    st.dataframe(df.tail(50), use_container_width=True)
    placeholder.empty()
else:
    st.info("Select ticker and press 'Run All' to fetch data, forecasts, and news.")
